#####################################   Анонимные, lambda функции   #######################################
############################  Идея: часто описывать функцию некогда и незачем   ###########################
# def sum(x):
#  return x+10

# def mult(x):
#  return x**2

# sum(mult(2))

############## тоже самое что и сверху ##########

# def sum(x): return x+10
# def mult(x): return x**2

# sum(mult(2))
# f(g(x))
# def h(f, g, x): return f(g(x))h = lambda f, g, x: f(g(x))

# h(sum, mult, 5)
# h(lambda x: x+10, lambda x: x**2, 5)

##############################  List Comprehension  ##########################

# [exp for item in iterable]
# [exp for item in iterable(if conditional)]
# [exp < if conditional > for item in iterable(if conditional)]

# list = []
# for i in range(1, 101):
#     if i % 2 == 0:
#         list.append(i)
# print(list)

# list = [(i, i) for i in range(1, 21) if i % 2 == 0]
# print(list)


# def f(x):
#     return x**3


# list = [(i, f(i)) for i in range(1, 21) if i % 2 == 0]
# print(list)

# # # # # # # # # # # # В файле хранятся числа, нужно выбрать четные и  ######
# # # # # # # # # # # # составить список пар(число квадрат числа).      ######
# # # # # # # # # # # # Пример:                                         ######
# # # # # # # # # # # # 1 2 3 5 8 15 23 38                              ######
# # # # # # # # # # # # Получить:                                       ######
# # # # # # # # # # # # [(2, 4), (8, 64), (38, 1444)]                   ######

# path='можно здесь указать путь к файлу и потом этот путь указывать вместо имени файла при его открытии и тп'
# f = open('f.txt', 'r')
# data = f.read() + ' '  # считывается все что есть в строке и добавляется пробел
# f.close()
# numbers = []
# while data != '':  # пробегаюсь по всей строку пока она не станет пустой
#     space_pos = data.index(' ')  # берем первую позицию пробела
#     numbers.append(int(data[:space_pos]))
#     # доб. в list все что нах-ся до пробела и переводим в int#
#     data = data[space_pos+1:]  # обновляем список
# out = []
# for e in numbers:
#     if not e % 2:
#         out.append((e, e ** 2))
# print(out)
################ А теперь тоже самое но с помощью lambda ##########
######## только опустили считывание из файла ######################
# def select(f, col):  # возвращает список заполненный
#     return [f(x) for x in col]  # по этому устовию


# def where(f, col):  # возвращает список f - условие
#     return [x for x in col if f(x)]  # поэтому условию производится фильтрация объектов


# data = '1 2 3 5 8 15 23 38'.split()  # получаем список заполненный строками
# data = select(int, data)  # переводим его в int
# data = where(lambda e: not e % 2, data)# проверяем на четность
# data = select(lambda e: (e, e**2), data)# формируем список по условию
# print(data)

# №№№№№№№№№№№№№№№ Функция map
# №№№№№№№№№№№№№№№ Функция map() применяет указанную функцию к
# №№№№№№№№№№№№№№№ каждому элементу итерируемого объекта и
# №№№№№№№№№№№№№№№ возвращает итератор с новыми объектами.
# f(x) ⇒ x + 10
# map(f, [1, 2, 3, 4, 5])
#         ↓  ↓  ↓  ↓  ↓
#       [11, 12, 13, 14, 15]
################## верхняя задача реализуемая через функцию map ##########
# data = '1 2 3 5 8 15 23 38'.split()
# data = list(map(int, data)) здесь list это преобразователь в тип list
# data = list(filter(lambda e: not e % 2, data))
# data = list(map(lambda e: (e, e**2), data))
# print(data)

######################### Функция filter ############################
######################### Функция filter() применяет указанную функцию к ################
######################### каждому элементу итерируемого объекта и #
######################### возвращает итератор с теми объектами, для #
######################### которых функция вернула True. #
# f(x) ⇒ x - чётное
#filter(f, [1, 2, 3, 4, 5])
# ↓
#[2, 4]
